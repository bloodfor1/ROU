---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by richardjiang.
--- DateTime: 2019/3/1 14:44
---
---@module ModuleMgr.LevelRewardMgr
module("ModuleMgr.LevelRewardMgr", package.seeall)

EventDispatcher = EventDispatcher.new()

g_level_gift = {}        -- 等级礼包网络数据
g_levelRewardInfos = nil -- 等级礼包数据
g_level_start = 10
g_level_end = 100

LEVEL_REWARD_REFRESH_ITEM = "LEVEL_REWARD_REFRESH_ITEM" -- 刷新奖励的按钮
LEVEL_REWARD_REFRESH_LEVEL = "LEVEL_REWARD_REFRSH_LEVEL" -- 等级变化刷新界面
AWARD_PREVIEW_GROW_REWARD = "AWARD_PREVIEW_GROW_REWARD"
AWARD_PREVIEW_LEVEL_REWARD = "AWARD_PREVIEW_LEVEL_REWARD"

local NEXT_SHOW_COUNT = 5  -- 超过等级继续显示的礼包数量
local gameEventMgr = MgrMgr:GetMgr("GameEventMgr")

function OnInit()
    Data.PlayerInfoModel.BASELV:Add(Data.onDataChange, OnBaseLvChange, ModuleMgr.DelegateModuleMgr)
    g_level_start = MGlobalConfig:GetInt("BaseDisplayMin")
    g_level_end = MGlobalConfig:GetInt("BaseDisplayMax")
    NEXT_SHOW_COUNT = MGlobalConfig:GetInt("BaseDisplayNumber")
    gameEventMgr.Register(gameEventMgr.OnBagUpdate, _onItemUpdate)
end

function OnLogout()
    g_level_gift = {}
    g_levelRewardInfos = nil
end

function OnSelectRoleNtf(info)
    if info.lua_activity_info and info.lua_activity_info.level_gift then
        g_level_gift = info.lua_activity_info.level_gift.level_gift_id
        RefreshServerLevelRewardInfos()
    end
end

function OnBaseLvChange()
    UpdateLevelRewardsInfo()
    EventDispatcher:Dispatch(LEVEL_REWARD_REFRESH_LEVEL)
    UpdateRedCheck()
end

function RefreshServerLevelRewardInfos()
    g_levelRewardInfos = {}
    local id, type
    for i, v in ipairs(g_level_gift) do
        id, type = v.key, v.value
        if not g_levelRewardInfos[id] then
            g_levelRewardInfos[id] = {}
        end
        local rewardInfo = g_levelRewardInfos[id]
        rewardInfo[type] = 1
        g_levelRewardInfos.id = id
    end
end

function GetLevelRewardInfos()
    if not g_levelRewardInfos then
        RefreshServerLevelRewardInfos()
    end
    return g_levelRewardInfos
end

function UpdateLevelRewardsInfo()
    local rewardInfos = GetLevelRewardInfos()
    local lv = MPlayerInfo.Lv
    local basePackageTable = TableUtil.GetBasePackageTable().GetTable()
    table.sort(basePackageTable, function(a, b)
        return a.Base < b.Base
    end)
    local extraShowCount = NEXT_SHOW_COUNT
    for i, v in ipairs(basePackageTable) do
        if lv >= v.Base or extraShowCount > 0 then
            if not rewardInfos[v.Id] then
                rewardInfos[v.Id] = { 0, 0 }
            else
                rewardInfos[v.Id].sdata = v
            end
            rewardInfos[v.Id].id = v.Id
            if lv < v.Base then
                extraShowCount = extraShowCount - 1
            end
        else
            break
        end
    end
    return rewardInfos
end

function ReceiveLevelGift(giftId, type)
    local l_msgId = Network.Define.Rpc.ReceiveLevelGift
    ---@type ReceiveLevelGiftArg
    local l_sendInfo = GetProtoBufSendTable("ReceiveLevelGiftArg")
    l_sendInfo.gift_id = giftId
    l_sendInfo.type = type
    Network.Handler.SendRpc(l_msgId, l_sendInfo)
end

--全局存一个这个回调的Arg
ReceiveLevelGiftArg = nil
function OnReceiveLevelGift(msg, sendArg)
    ---@type ReceiveLevelGiftRes
    local l_info = ParseProtoBufToTable("ReceiveLevelGiftRes", msg)
    ReceiveLevelGiftArg = table.ro_clone(sendArg)

    if l_info.result ~= 0 then
        if l_info.result == ErrorCode.ERR_IN_PAYING then
            game:GetPayMgr():RegisterPayResultCallback(Network.Define.Rpc.ReceiveLevelGift, ReceiveLevelGiftSuccessFunc)
            return
        end
        MgrMgr:GetMgr("TipsMgr").ShowNormalTips(Common.Functions.GetErrorCodeStr(l_info.result))
        return
    end
    ReceiveLevelGiftSuccessFunc()
end

function ReceiveLevelGiftSuccessFunc()
    local l_sendArg = ReceiveLevelGiftArg
    local levelGiftInfo = g_levelRewardInfos[l_sendArg.gift_id]
    if not levelGiftInfo then
        g_levelRewardInfos[l_sendArg.gift_id] = {}
        levelGiftInfo = g_levelRewardInfos[l_sendArg.gift_id]
        levelGiftInfo.sdata = TableUtil.GetBasePackageTable().GetRowById(l_sendArg.gift_id)
    end
    levelGiftInfo[l_sendArg.type] = 1
    EventDispatcher:Dispatch(LEVEL_REWARD_REFRESH_ITEM, l_sendArg.gift_id, levelGiftInfo)
    UpdateRedCheck()
end

function CheckRedSignMethod()
    local rewards = UpdateLevelRewardsInfo()
    local lv = MPlayerInfo.Lv
    for id, v in ipairs(rewards) do
        local sdata = v.sdata
        if not sdata then
            sdata = TableUtil.GetBasePackageTable().GetRowById(id)
        end
        if sdata == nil then
            return 0
        end
        if lv >= sdata.Base then
            if not v[0] or v[0] == 0 then
                return 1
            end
        end
    end
    return 0
end

function UpdateRedCheck()
    local redMgr = MgrMgr:GetMgr("RedSignMgr")
    redMgr.UpdateRedSign(eRedSignKey.LevelReward)
end

---@param itemUpdateDataList ItemUpdateData[]
function _onItemUpdate(itemUpdateDataList)
    if nil == itemUpdateDataList then
        logError("[LevelRewardMgr] invalid param")
        return
    end

    local title = Common.Utils.Lang("Achievement_GetBadgeGetAwardText")
    local tipsTitle = Common.Utils.Lang("Landing_GetAwardText")
    local C_REASON_MAP = {
        [ItemChangeReason.ITEM_REASON_LEVEL_GIFT] = 1,
        [ItemChangeReason.ITEM_REASON_LEVEL_GIFT_BUY] = 1,
    }

    ---@type ItemIdCountPair[]
    local itemPairList = {}
    for i = 1, #itemUpdateDataList do
        local singleUpdateData = itemUpdateDataList[i]
        if nil ~= C_REASON_MAP[singleUpdateData.Reason] and nil ~= singleUpdateData.NewItem then
            local compareData = singleUpdateData:GetItemCompareData()
            ---@type ItemIdCountPair
            local singlePair = {
                id = compareData.id,
                count = compareData.count,
            }

            table.insert(itemPairList, singlePair)
            if ItemChangeReason.ITEM_REASON_LEVEL_GIFT_BUY == singleUpdateData.Reason then
                title = Common.Utils.Lang("Level_Gift_Buy")
            end
        end
    end

    local mergeList = _mergeData(itemPairList)
    MgrMgr:GetMgr("TipsMgr").ShowAwardItemTips(mergeList, title, tipsTitle)
end

--- 合并数据，原因是可能有道具达到了堆叠上限，这个时候会分成两个道具发过来，显示上回分开
---@param pairDataList ItemIdCountPair[]
---@return ItemIdCountPair[]
function _mergeData(pairDataList)
    if nil == pairDataList then
        logError("[LvReward] invalid param")
        return {}
    end

    local hashMap = {}
    for i = 1, #pairDataList do
        local singlePair = pairDataList[i]
        if nil == hashMap[singlePair.id] then
            hashMap[singlePair.id] = singlePair.count
        else
            hashMap[singlePair.id] = hashMap[singlePair.id] + singlePair.count
        end
    end

    local ret = {}
    for id, value in pairs(hashMap) do
        ---@type ItemIdCountPair
        local singleData = {
            id = id,
            count = value
        }

        table.insert(ret, singleData)
    end

    return ret
end

return ModuleMgr.LevelRewardMgr