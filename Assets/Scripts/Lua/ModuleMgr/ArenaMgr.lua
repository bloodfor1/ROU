---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by richardjiang.
--- DateTime: 2018/9/11 16:04
---
module("ModuleMgr.ArenaMgr", package.seeall)
EventDispatcher = EventDispatcher.new()

-- 擂台配置
ArenaFactionMembers = MGlobalConfig:GetInt("ArenaFactionMembers") -- 阵营人数
ArenaFactionPoints = MGlobalConfig:GetInt("ArenaFactionPoints") -- 每个阵营的点数
ArenaPerPoint = math.floor(ArenaFactionPoints / ArenaFactionMembers) -- 每个人的点数
ArenaMinLv = MGlobalConfig:GetInt("ArenaMinLv") -- 最低参加等级
ArenaMaxLv = MGlobalConfig:GetInt("ArenaMaxLv") -- 最高参加等级
ArenaTopFactionsCount = MGlobalConfig:GetInt("ArenaTopFactionsCount") -- 初始放在第二层的阵营数
ArenaBattleRounds = MGlobalConfig:GetInt("ArenaBattleRounds") -- 总战斗轮数
ArenaCountDownBeforeBattle = MGlobalConfig:GetInt("ArenaCountDownBeforeBattle")
ArenaCountDownAfterMatching = MGlobalConfig:GetInt("ArenaCountDownAfterMatching")
ArenaIntermissionTime = MGlobalConfig:GetInt("ArenaIntermissionTime") -- 中场休息时间（秒）
ArenaResultCountDown = MGlobalConfig:GetInt("ArenaResultCountDown") -- 结算界面退出倒计时（秒）
ArenaRevivalCountDown = MGlobalConfig:GetInt("ArenaRevivalCountDown") -- 复活按钮上的倒计时（秒）
ArenaAfkTime1 = MGlobalConfig:GetInt("ArenaAfkTime1") -- 挂机警告弹窗出现的时间（秒）
ArenaAfkTime2 = MGlobalConfig:GetInt("ArenaAfkTime2") -- 挂机警告弹窗出现后不扣奖励的时间（秒）
ArenaAfkTime3 = MGlobalConfig:GetInt("ArenaAfkTime3") -- 扣除奖励到0的最大挂机时间
ArenaWaitSceneId = MGlobalConfig:GetInt("ArenaWaitSceneId") -- 等候區场景id(开战前)
ArenaWaitSceneIdAfterFight = MGlobalConfig:GetInt("ArenaWaitSceneIdAfterFight") -- 等候區场景id(开战后)

EventCountDownUpdate = "EventCountDownUpdate" -- 倒计时更新
EventFightCountDownUpdate = "EventFightCountDownUpdate" -- 战斗倒计时更新
EventPrepareFightCountDownUpdate = "EventPrepareFightCountDownUpdate" -- 战斗倒计时更新
EventStartMatch = "EventStartMatch" -- 开始匹配
EventMatchSucc = "EventMatchSucc" -- 匹配成功
EventMatchFail = "EventMatchFail" -- 匹配失敗
EventUpdateScore = "EventUpdateScore" -- 擂台更新分数
EventPlatformTeamRequireNumUpdate = "EventPlatformTeamRequireNumUpdate" -- 参加擂台的队伍需要人数变化
ArenaUpdateScoreEvent="ArenaUpdateScoreEvent" --决斗场更新分数

ResultInfo = {}
Result = false
CountDown = 120
CountDownTimer = nil
FightCountDown = 0
FightTimer = nil
FightPrepareTimer = nil
FightPrepareCountDown = 0
m_passTime = 0
m_battleTime = 0
m_type = nil
m_prepareCountDown = ArenaCountDownBeforeBattle
m_fightOver = false
LeftLifes = {}

BattleRedScore=0
BattleBlueScore=0

local joinRanges = nil -- 参加等级区间

function OnSelectRoleNtf(roleData)
    if roleData and roleData.dungeons and roleData.dungeons.platform then
        MPlayerDungeonsInfo.PlatFormFloor = roleData.dungeons.platform.cur_floor + 1
    end
end

--==============================--
--@Description:报名
--@Date: 2018/9/17
--@Param: [args]
--@Return:
--==============================--
function JoinArena()
    local l_msgId = Network.Define.Rpc.BattlefieldApply
    ---@type PVPApplyArg
    local l_sendInfo = GetProtoBufSendTable("PVPApplyArg")
    l_sendInfo.type = MgrMgr:GetMgr("DailyTaskMgr").g_ActivityType.activity_Ring
    Network.Handler.SendRpc(l_msgId, l_sendInfo)
end

--==============================--
--@Description:报名成功
--@Date: 2018/9/17
--@Param: [args]
--@Return:
--==============================--
function OnBattlefieldApply(l_info)
end

function OnReconnected(reconnectData)
    local l_dungeons = reconnectData.dungeons
    local l_arena_reconnect=l_dungeons.arena_reconnect

    SetBattleScore(l_arena_reconnect.camp1_roles,l_arena_reconnect.camp1_kill_nums,l_arena_reconnect.camp2_kill_nums)
end

function OnLuaDoEnterScene(reconnectData)
    local l_dungeons = reconnectData.dungeons
    local l_arena_reconnect=l_dungeons.arena_reconnect

    SetBattleScore(l_arena_reconnect.camp1_roles,l_arena_reconnect.camp1_kill_nums,l_arena_reconnect.camp2_kill_nums)
end

function OnLogout()
    BattleRedScore=0
    BattleBlueScore=0
end

-- 进入等候区
function EnterWaitingArena()
    GlobalEventBus:Dispatch(EventConst.Names.ARENA_CLOSE_OFFER)
end

-- 离开等候区
function LeaveWaitingArena()
    StopCountDown()
    if MEntityMgr.PlayerEntity then
        MgrMgr:GetMgr("DungeonMgr").HideLifeHUD(MEntityMgr.PlayerEntity.UID)
        --MEventMgr:LuaFireEvent(MEventType.MEvent_DungeonLife_Change, MEntityMgr.PlayerEntity, "0", true)
    end
end

-- 进入战斗
function EnterFight()
    BattleRedScore=0
    BattleBlueScore=0
    m_fightOver = false
    StartFightPrepareCountDown()
    InitMemberLife()
end

function EnterFightUI()
    UIMgr:ActiveUI(UI.CtrlNames.BattleArena)
end
-- 离开战斗
function LeaveFight()
    m_fightOver = false
    StopFightCountDown()
    StopFightPrepareCountDown()
    local ui = UIMgr:GetUI(UI.CtrlNames.BattleCountDown)
    if ui then
        UIMgr:DeActiveUI(UI.CtrlNames.BattleCountDown)
    end
    if MEntityMgr.PlayerEntity then
        MgrMgr:GetMgr("DungeonMgr").HideLifeHUD(MEntityMgr.PlayerEntity.UID)
        --MEventMgr:LuaFireEvent(MEventType.MEvent_DungeonLife_Change, MEntityMgr.PlayerEntity, "0", true)
    end
end

function InitMemberLife()
    local iter = MPlayerDungeonsInfo.LeftLifeCounter:GetEnumerator()
    local k, v, e
    while iter:MoveNext() do
        k, v = iter.Current.Key, iter.Current.Value
        LeftLifes[tostring(k)] = v
        e = MEntityMgr:GetEntity(k)
        if e then
            MgrMgr:GetMgr("DungeonMgr").ShowLifeHUD(2, v, v, e.UID)
            --MEventMgr:LuaFireEvent(MEventType.MEvent_DungeonLife_Change, e, tostring(v), false)
        end
    end
end

function InitMemberLifeByWatch(info)

    if not info then return end

    LeftLifes = {}
    for i, v in ipairs(info) do
        LeftLifes[tostring(v.first)] = v.second
        local l_entity = MEntityMgr:GetEntity(v.first)
        if l_entity then
            MgrMgr:GetMgr("DungeonMgr").ShowLifeHUD(2, v.second, v.second, l_entity.UID)
        end
    end
end

-- 获取参加的等级区间段
function GetJoinLvRange()
    local arenaActivityId = MgrMgr:GetMgr("DailyTaskMgr").g_ActivityType.activity_Ring
    local lv = MPlayerInfo.Lv
    if not joinRanges then
        joinRanges = {}
        local battleGroundLvRangeTable = TableUtil.GetBattleGroundLvRangeTable().GetTable()
        for i, v in ipairs(battleGroundLvRangeTable) do
            if v.Type == arenaActivityId then
                table.insert(joinRanges, {
                    minLv = v.Scenes[0],
                    maxLv = battleGroundLvRangeTable[i + 1] and battleGroundLvRangeTable[i + 1].Scenes[0] or 200,
                    waitSceneId = v.Scenes[1],
                    dungeons = v.Dungeons,
                })
            end
        end
    end

    local minLv, maxLv = -1, -1
    for i, v in ipairs(joinRanges) do
        if lv >= v.minLv and lv < v.maxLv then
            minLv, maxLv = v.minLv, v.maxLv
            break
        end
    end
    return minLv, maxLv
end

--==============================--
--@Description: 开始倒计时
--@Date: 2018/9/13
--@Param: [args]
--@Return:
--==============================--
function StartCountDown()
    StopCountDown()

    local dailyTaskMgr = MgrMgr:GetMgr("DailyTaskMgr")
    local leftTime, round = dailyTaskMgr.GetRoundFightInfo()
    if round > 0 then
        MEventMgr:LuaFireEvent(MEventType.MEvent_DungeonLife_Change, MEntityMgr.PlayerEntity, StringEx.Format("{0}F", MEntityMgr.PlayerEntity.AttrRole.Floor + 1), false)
    end
    if round == 0 then
        local l_time = dailyTaskMgr.GetBattleTime(dailyTaskMgr.g_ActivityType.activity_Ring)
        CountDown = MLuaClientHelper.GetTiks2NowSeconds(l_time)
    elseif round == ArenaBattleRounds then
        logGreen("arena is over")
        return
    else
        CountDown = math.ceil(leftTime / 1000)
    end
    if CountDown >= 0 then
        EventDispatcher:Dispatch(EventCountDownUpdate, CountDown)
        if CountDown > 0 then
            CountDownTimer = Timer.New(function()
                CountDown = math.max(0, CountDown - 1)
                EventDispatcher:Dispatch(EventCountDownUpdate, CountDown)
                if CountDown <= 0 then
                    StopCountDown()
                    StartMatch()
                end
            end, 1, -1)
            CountDownTimer:Start()
        else
            StartMatch()
        end
    else
        logGreen("enter waiting room is infight")
    end
end

--==============================--
--@Description: 停止倒计时
--@Date: 2018/9/13
--@Param: [args]
--@Return:
--==============================--
function StopCountDown()
    if CountDownTimer then
        CountDownTimer:Stop()
        CountDownTimer = nil
    end
end

--==============================--
--@Description:开始战斗准备倒计时
--@Date: 2018/9/15
--@Param: [args]
--@Return:
--==============================--
function StartFightPrepareCountDown()
    StopFightPrepareCountDown()
    InitTimeInfo()
    FightPrepareCountDown = m_prepareCountDown
    if FightPrepareCountDown > 0 then
        EventDispatcher:Dispatch(EventPrepareFightCountDownUpdate, FightPrepareCountDown)
        FightPrepareTimer = Timer.New(function()
            InitMemberLife()
            FightPrepareCountDown = math.max(0, FightPrepareCountDown - 1)
            EventDispatcher:Dispatch(EventPrepareFightCountDownUpdate, FightPrepareCountDown)
            if FightPrepareCountDown == 3 then
                UIMgr:ActiveUI(UI.CtrlNames.BattleCountDown)
            elseif FightPrepareCountDown <= 0 then
                StopFightPrepareCountDown()
                StartFightCountDown()
            end
        end, 1, -1)
        FightPrepareTimer:Start()
    else
        m_battleTime = m_battleTime + ArenaCountDownBeforeBattle
        StartFightCountDown()
    end

end

--==============================--
--@Description:停止战斗倒计时
--@Date: 2018/9/15
--@Param: [args]
--@Return:
--==============================--
function StopFightPrepareCountDown()
    if FightPrepareTimer then
        FightPrepareTimer:Stop()
        FightPrepareTimer = nil
        FightPrepareCountDown = 0
    end
end

--==============================--
--@Description:开始战斗倒计时
--@Date: 2018/9/15
--@Param: [args]
--@Return:
--==============================--
function StartFightCountDown()
    StopFightCountDown()
    if m_passTime < m_battleTime then
        FightCountDown = math.floor(m_battleTime - m_passTime + 0.5) -- 四舍五入
        FightTimer = Timer.New(function()
            FightCountDown = math.max(0, FightCountDown - 1)
            EventDispatcher:Dispatch(EventFightCountDownUpdate, FightCountDown)
            if FightCountDown <= 0 then
                StopFightCountDown()
            end
        end, 1, -1)
        FightTimer:Start()
    else
        -- 退出战斗fb
    end
end

--==============================--
--@Description:停止战斗倒计时
--@Date: 2018/9/15
--@Param: [args]
--@Return:
--==============================--
function StopFightCountDown()
    if FightTimer then
        FightTimer:Stop()
        FightTimer = nil
        FightCountDown = 0
    end
end

--==============================--
--@Description: 成员是否都在等候区
--@Date: 2018/9/13
--@Param: [args]
--@Return:
--==============================--
function IsAllMemberInWaitingScene()
    local teamMemCount = DataMgr:GetData("TeamData").GetTeamNum()
    local stageEnum = StageMgr:GetCurStageEnum()

    if teamMemCount > 0 then
        return DataMgr:GetData("TeamData").IsAllMemberInSameScene(ArenaWaitSceneId) or DataMgr:GetData("TeamData").IsAllMemberInSameScene(ArenaWaitSceneIdAfterFight)
    else
        return MScene.SceneID == ArenaWaitSceneId or MScene.SceneID == ArenaWaitSceneIdAfterFight
    end
end

-- 开始匹配
function StartMatch()
    local teamMemCount = DataMgr:GetData("TeamData").GetTeamNum()
    if teamMemCount > ArenaFactionMembers then
        -- 人数超额
        return MgrMgr:GetMgr("TipsMgr").ShowNormalTips(Lang("ARENA_TEAM_TOO_BIG", ArenaFactionMembers))
    end
end

--==============================--
--@Description: 轮空晋级
--@Date: 2018/9/21
--@Param: [args]
--@Return:
--==============================--
function OnDirectPromote()
    -- 重新开始擂台倒计时
    local player = MEntityMgr.PlayerEntity
    if not player then
        return
    end
    player.AttrRole.Floor = player.AttrRole.Floor + 1
    if player.AttrRole.Floor < ArenaBattleRounds then
        MgrMgr:GetMgr("TipsMgr").ShowNormalTips(Common.Utils.Lang("ARENA_FREE_WIN"))
    else
        MgrMgr:GetMgr("TipsMgr").ShowNormalTips(Common.Utils.Lang("ARENA_FREE_WIN_FINAL", player.AttrRole.Floor))
    end
    MgrMgr:GetMgr("DailyTaskMgr").UpdateDailyTaskInfo()
end

function FormatDirectPromoptResult()
    local ret = { round = 0, player = {}, hideLike = true }
    local round, time = MgrMgr:GetMgr("DailyTaskMgr").GetRoundFightInfo()
    ret.round = round
    local playeIds = DataMgr:GetData("TeamData").GetTeamPlayerIds()
    for i, v in ipairs(playeIds) do
        ret.player[v] = {
            kill = 0,
            help = 0,
            score = 0,
        }
    end
    return ret
end

-- 结算
function OnDungeonsResult(msg)
    m_fightOver = true
    ---@type DungeonsResultData
    local l_info = ParseProtoBufToTable("DungeonsResultData", msg)
    -- log("OnDungeonsResult", ToString(l_info))
    local player = MEntityMgr.PlayerEntity
    if not player then
        return
    end
    BattleRedScore=0
    BattleBlueScore=0
    ResultInfo = {
        player = {},
        other = {},
        statistics = {},
        score = {
        },
        attrs = l_info.attrs,
        round = l_info.pvp.round_id,
        floor = l_info.platform_statistics.floor,
    }

    ResultInfo.status = l_info.status
    player.AttrRole.Floor = ResultInfo.floor or 0

    local l_playerId = player.UID
    if MgrMgr:GetMgr("WatchWarMgr").IsInSpectator() then
        l_playerId = MPlayerInfo.WatchFocusPlayerId
    end

    local playerCamp, otherCamp
    local isPlayer = array.find(l_info.pvp.camp1.role_ids, function(v)
        --logError("v.value   -->>"..tostring(v.value),"l_playerId  "..tostring(l_playerId),tostring(v.value:equals(l_playerId)))
        return v.value:equals(l_playerId)
    end)

    if isPlayer then
        playerCamp, otherCamp = l_info.pvp.camp1, l_info.pvp.camp2
        ResultInfo.score[1], ResultInfo.score[2] = l_info.platform_statistics.camp1_remain_points, l_info.platform_statistics.camp2_remain_points
    else
        playerCamp, otherCamp = l_info.pvp.camp2, l_info.pvp.camp1
        ResultInfo.score[2], ResultInfo.score[1] = l_info.platform_statistics.camp1_remain_points, l_info.platform_statistics.camp2_remain_points
    end
    l_inA = MEntityMgr.PlayerEntity.AttrRole.FightGroup == l_camp
    local max_score = 0
    local pvpMgr = MgrMgr:GetMgr("PvpMgr")
    local mvpId, otherMvpId
    for _, v in ipairs(playerCamp.role_ids) do
        local l_kill, l_help, l_score, l_beKill = pvpMgr.GeneratePvpCountersInfo(v.value, playerCamp.role_infos)
        ResultInfo.player[v.value] = {
            kill = l_kill,
            help = l_help,
            score = l_score,
            beKill = l_beKill,
        }
        if l_score > max_score or not mvpId then
            mvpId = v.value
            max_score = l_score
        end
    end
    max_score = 0
    for _, v in ipairs(otherCamp.role_ids) do
        local l_kill, l_help, l_score, l_beKill = pvpMgr.GeneratePvpCountersInfo(v.value, otherCamp.role_infos)
        ResultInfo.other[v.value] = {
            kill = l_kill,
            help = l_help,
            score = l_score,
            beKill = l_beKill,
        }
        if l_score > max_score or not otherMvpId then
            otherMvpId = v.value
            max_score = l_score
        end
    end
    if l_info.platform_statistics then
        for i, v in ipairs(l_info.platform_statistics.role_life_counter) do
            ResultInfo.statistics[tostring(v.first)] = v.second or 0
        end
    end
    ResultInfo.mvpId = mvpId
    ResultInfo.otherMvpId = otherMvpId
    --UIMgr:HideTipsContainer()
    local dailyTaskMgr = MgrMgr:GetMgr("DailyTaskMgr")
    pvpMgr.ExcuteCameraTex(mvpId, dailyTaskMgr.g_ActivityType.activity_Ring)
end

function GetRingResult()
    return ResultInfo
end

function InitTimeInfo()
    ---断线重连
    m_passTime = MgrMgr:GetMgr("DungeonMgr").GetDungeonsPassTime()
    m_prepareCountDown = math.max(0, ArenaCountDownBeforeBattle - m_passTime)
    local dungeonData = TableUtil.GetDungeonsTable().GetRowByDungeonsID(MPlayerDungeonsInfo.DungeonID)
    if dungeonData and dungeonData.TimeLimit then
        local l_dataType = dungeonData.TimeLimit:get_Item(0)
        local l_dataSec = dungeonData.TimeLimit:get_Item(1)
        m_battleTime = l_dataSec
        m_type = l_dataType
    else
        m_battleTime = 0
        m_type = nil
    end
end

function UpdateRoleDeadNum(_self, deadEntity)

    local uid = tostring(deadEntity.UID)
    if not LeftLifes[uid] then
        LeftLifes[uid] = ArenaPerPoint
    end
    LeftLifes[uid] = math.max(0, LeftLifes[uid] - 1)
    local l_dungeonMgr = MgrMgr:GetMgr("DungeonMgr")
    local dungeonType = MPlayerInfo.PlayerDungeonsInfo.DungeonType
    if dungeonType == l_dungeonMgr.DungeonType.DungeonPvp then
        LeftLifes[uid] = 1
    end
    MPlayerDungeonsInfo.LeftLifeCounter:set_Item(deadEntity.UID, LeftLifes[uid])
    local stage = StageMgr:GetCurStageEnum()
    if stage == MStageEnum.Ring then
        MgrMgr:GetMgr("DungeonMgr").ShowLifeHUD(2, LeftLifes[uid], LeftLifes[uid], deadEntity.UID)
    end

    EventDispatcher:Dispatch(EventUpdateScore)
end

function ReceiveArenaSyncScoreNtf(msg)
    local l_info = ParseProtoBufToTable("ArenaSyncScoreData", msg)
    SetBattleScore(l_info.camp1_roles,l_info.camp1_score,l_info.camp2_score)

end

function SetBattleScore(roles,score1,score2)
    local isPlayerAtCamp1=false
    for i = 1, #roles do
        if MPlayerInfo.UID==roles[i] then
            isPlayerAtCamp1=true
            break
        end
    end

    if isPlayerAtCamp1 then
        BattleRedScore=score1
        BattleBlueScore=score2
    else
        BattleRedScore=score2
        BattleBlueScore=score1
    end

    EventDispatcher:Dispatch(ArenaUpdateScoreEvent)
end







function IsFightOver()
    return m_fightOver
end

function GetTeamRequireNum()
    return ArenaFactionMembers
end

function SetTeamRequireNum(num)
    ArenaFactionMembers = num
    EventDispatcher:Dispatch(EventPlatformTeamRequireNumUpdate)
end

return ArenaMgr